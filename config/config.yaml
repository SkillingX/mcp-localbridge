# MCP LocalBridge Configuration File
# Environment variables take precedence over config.yaml values

# Server configuration
server:
  name: "MCP LocalBridge"
  version: "1.0.0"
  # Request timeout in seconds
  request_timeout: 60
  # Enable recovery from panics
  enable_recovery: true

# Logging configuration
logging:
  # Log level: debug, info, warn, error
  level: "debug"
  # Log format: json, text
  format: "json"
  # Log output: stdout, stderr, file path
  output: "logs/mcp-localbridge.log"

# ============================================================
# Transport Configurations
# ============================================================
# MCP LocalBridge supports multiple transport protocols

transports:
  # ----------------------------------------------------------
  # Stdio Transport - Standard Input/Output
  # ----------------------------------------------------------
  # Purpose: Local IDE integration (Claude Desktop, Cursor, VS Code)
  # How it works: Communication through process stdin/stdout
  # Advantages: Fast startup, easy debugging, no network ports required
  # Disadvantages: Only supports local single-process communication
  # Recommended for: Local development, IDE integration
  stdio:
    enabled: true

  # ----------------------------------------------------------
  # SSE Transport - Server-Sent Events (RECOMMENDED for HTTP)
  # ----------------------------------------------------------
  # IMPORTANT: SSE is the standard HTTP-based transport for MCP protocol
  #
  # Purpose: Docker deployment, web clients, remote access, HTTP-based IDE integration
  # How it works: Real-time streaming over HTTP (standard HTTP protocol)
  #
  # Advantages:
  #   - Uses standard HTTP/HTTPS protocol, firewall-friendly
  #   - Supports multiple concurrent client connections
  #   - Built-in automatic reconnection mechanism
  #   - Perfect for containerized deployments
  #   - Works through proxies and load balancers
  #
  # HTTP Endpoints (auto-generated):
  #   - GET  {base_path}{sse_endpoint}      -> SSE streaming connection
  #   - POST {base_path}{message_endpoint}  -> Message posting
  #
  # Actual endpoints (with this config):
  #   - SSE connection: http://localhost:28028/api/mcp/sse
  #   - Message posting: http://localhost:28028/api/mcp/message
  #
  # IDE configuration uses base URL:
  #   - Cursor: http://localhost:28028/api/mcp
  #   - VS Code: http://localhost:28028/api/mcp
  #
  # Recommended scenarios:
  #   - Docker container deployment
  #   - Cursor IDE remote connection
  #   - Web application integration
  #   - Cross-network access
  sse:
    enabled: true
    host: "0.0.0.0"                # Listen on all network interfaces
    port: 28028                    # SSE service port
    base_path: "/api/mcp"          # API base path
    sse_endpoint: "/sse"           # SSE connection endpoint (relative to base_path)
    message_endpoint: "/message"   # Message endpoint (relative to base_path)
    keepalive_interval: 30         # Keepalive heartbeat interval (seconds)

  # ----------------------------------------------------------
  # HTTP Transport - Placeholder (Not Implemented)
  # ----------------------------------------------------------
  # WARNING: This transport is reserved for future use and not currently implemented
  #
  # Note:
  #   The mcp-go v0.11.0 library does not provide traditional HTTP JSON-RPC API
  #   All HTTP-based MCP communication should use the SSE transport above
  #
  # SSE vs HTTP comparison:
  #   - SSE is the standard MCP HTTP implementation (recommended)
  #   - SSE provides real-time bidirectional streaming communication
  #   - HTTP (this one) is reserved for future possible RESTful JSON-RPC
  #
  # Current status: Placeholder, recommended to keep disabled
  # For HTTP-based MCP functionality, use SSE transport above
  http:
    enabled: false                 # Not implemented, keep disabled
    host: "0.0.0.0"
    port: 28027                    # Reserved port
    endpoint_path: "/mcp"
    heartbeat_interval: 30
    stateless: false

  # ----------------------------------------------------------
  # InProcess Transport - Direct In-Process Calls
  # ----------------------------------------------------------
  # Purpose: Unit tests, performance benchmarks, embedded scenarios
  # How it works: Direct function calls, no network or serialization
  # Advantages: Zero latency, no network overhead, easy debugging
  # Disadvantages: Limited to same process only
  # Recommended for: Testing, performance analysis
  inprocess:
    enabled: false

# Database configurations
# Note: This project does NOT start database containers.
# It assumes databases are already running on the host machine.
databases:
  # MySQL instances
  mysql:
    - name: "mysql_main"
      enabled: true
      # Use host.docker.internal to connect to host databases from Docker
      # Linux users need to configure extra_hosts in docker-compose.yml
      host: "host.docker.internal"
      port: 3306
      user: "root"
      password: "password"
      database: "main"
      # Connection pool settings
      max_open_conns: 25
      max_idle_conns: 5
      conn_max_lifetime: 300  # seconds

  # PostgreSQL instances
  postgres:
    - name: "postgres_main"
      enabled: false
      host: "host.docker.internal"
      port: 5432
      user: "postgres"
      password: "password"
      database: "main"
      sslmode: "disable"
      max_open_conns: 25
      max_idle_conns: 5
      conn_max_lifetime: 300  # seconds

# Redis configurations
redis:
  instances:
    - name: "redis_main"
      enabled: true
      host: "host.docker.internal"
      port: 6379
      password: ""
      db: 0
      # Connection pool settings
      pool_size: 10
      min_idle_conns: 2
      # Dial timeout in seconds
      dial_timeout: 5
      # Read/Write timeout in seconds
      read_timeout: 3
      write_timeout: 3

# MCP Tools configuration
tools:
  # Database query tools
  db:
    # Default to dry-run mode (returns preview SQL without execution)
    # Recommended to keep enabled in production; control execution via tool parameters
    default_dry_run: true
    # Maximum rows to return in query results
    max_rows: 1000
    # Query timeout in seconds
    query_timeout: 30
    # Enable table data preview
    enable_preview: true
    preview_limit: 10

  # Redis tools
  redis:
    # Maximum keys to return in scan operations
    max_scan_keys: 100
    # Scan count per iteration
    scan_count: 10

  # Insights tools
  insights:
    # Introspection cache settings
    introspection:
      # Cache TTL in seconds
      cache_ttl: 3600
      # Use Redis cache (if false, use in-memory cache only)
      use_redis_cache: true

    # Semantic summary settings
    semantic_summary:
      # Number of sample rows to analyze
      sample_size: 100
      # Maximum columns to include in summary
      max_columns: 50

    # Analytics settings
    analytics:
      # Maximum aggregation result rows
      max_result_rows: 1000
      # Execution timeout in seconds
      execution_timeout: 60

    # Relationship analysis settings
    relationship:
      # Maximum depth for foreign key traversal
      max_depth: 3
      # Cache relationship graph
      cache_enabled: true
      cache_ttl: 7200  # seconds
